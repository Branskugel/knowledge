**00:04:44**  
**Solid. Что это, зачем нужно, как можно заметить, что нарушен принцип.**  
  
**Ответ:**  
SOLID — это набор пяти принципов объектно-ориентированного проектирования, которые помогают сделать код более гибким, расширяемым и поддерживаемым. Принципы SOLID:
- **S** (Single Responsibility Principle) — принцип единственной ответственности.
- **O** (Open/Closed Principle) — принцип открытости/закрытости.
- **L** (Liskov Substitution Principle) — принцип подстановки Барбары Лисков.
- **I** (Interface Segregation Principle) — принцип разделения интерфейса.
- **D** (Dependency Inversion Principle) — принцип инверсии зависимостей.

Если принцип нарушен, можно заметить чрезмерную связанность кода, сложность при внесении изменений или необходимость часто модифицировать существующий код, а не добавлять новый.

---

**00:06:25**  
**Open/Close для чего закрыт, для чего открыт?**  
  
**Ответ:**  
Принцип открытости/закрытости (Open/Closed Principle) гласит, что классы должны быть **закрыты для модификации** и **открыты для расширения**. Это означает, что функциональность класса не должна изменяться напрямую, но должна расширяться через наследование или композицию. Например, вместо изменения кода класса добавляются новые классы или модули для добавления нового поведения.

---

**00:08:30**  
**Liskov**  
  
**Ответ:**  
Принцип подстановки Лисков (Liskov Substitution Principle) гласит, что объекты подклассов должны могли бы замещать объекты базового класса без изменения корректности программы. Если подкласс изменяет поведение базового класса так, что вызывает неожиданные ошибки или нарушения логики, то нарушается принцип Лисков. Например, если при наследовании поведения метода подкласса меняются контракты, то это нарушение LSP.

---

**00:10:54**  
**Как проверить нарушение Open/Closed? Как бы ты на code review проверил бы нарушение этого принципа?**  
  
**Ответ:**  
Нарушение Open/Closed легко заметить, если изменения вносятся непосредственно в существующие классы, вместо добавления новых расширений через наследование или интерфейсы. На code review я бы проверил, не были ли изменены внутренние детали классов и функции, а также рассмотрел бы возможности добавления новой функциональности через расширение, а не изменение существующего кода.

---

**00:12:40**  
**SOLID в контрактах между микросервисами. Принцип хорошего проектирования контрактов.**  
  
**Ответ:**  
В микросервисной архитектуре принципы SOLID могут применяться к проектированию API и контрактов между сервисами. Например:
- Принцип единственной ответственности (SRP) требует, чтобы контракт обеспечивал только одну задачу.
- Принцип открытости/закрытости (OCP) подсказывает, что новые версии контрактов должны вводиться без изменения старых.
- Принцип разделения интерфейсов (ISP) означает, что контракты не должны быть слишком универсальными — клиенты должны получать только необходимые им данные.

---

**00:13:20**  
**Dependency Inversion**  
  
**Ответ:**  
Принцип инверсии зависимостей (Dependency Inversion Principle, DIP) заключается в том, что высокоуровневые модули не должны зависеть от низкоуровневых, и те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций. DIP позволяет легче изменять и расширять системы, так как зависимости устанавливаются через интерфейсы и абстрактные классы, а не конкретные реализации.

---

**00:16:44**  
**Что такое зависимости между микросервисами?**  
  
**Ответ:**  
Зависимости между микросервисами — это ситуации, когда один микросервис не может выполнять свои функции без взаимодействия с другим микросервисом. Это может быть вызвано необходимостью запроса данных или услуг у другого сервиса для завершения своей задачи. Сильные зависимости увеличивают сложность системы и усложняют её масштабируемость.

---

**00:17:48**  
**Что значит один микросервис зависит от другого?**  
  
**Ответ:**  
Зависимость одного микросервиса от другого означает, что первый не может функционировать без взаимодействия со вторым. Например, если сервис А для своей работы запрашивает данные из сервиса Б, то А зависит от Б. Если сервис Б выйдет из строя, сервис А также не сможет выполнять свою работу.

---

**00:21:30**  
**Отличие значимого и ссылочного типа**  
  
**Ответ:**  
Значимые типы (например, `int`, `struct`) хранят свои данные непосредственно в памяти переменной, тогда как ссылочные типы (например, `class`) содержат указатель на объект, который хранится в куче. Основное различие — значимые типы копируются при передаче по значению, а ссылочные типы передаются по ссылке, и изменение данных через одну ссылку отразится на всех её копиях.

---

**00:22:48**  
**Есть ли разница в памяти, которая выделяется под ссылочный и значимый тип при инициализации?**  
  
**Ответ:**  
Да, есть разница. Для значимого типа память выделяется в стеке, и он хранит свои данные непосредственно. Для ссылочного типа память выделяется как в стеке (для ссылки), так и в куче (для самого объекта). В куче выделяется дополнительная память для хранения метаданных объекта, таких как указатель на таблицу методов и состояние объекта.

---

**00:23:30**  
**Есть у меня int значение, одно в структуре хранится, а другое в классе, я их инициализирую, суммарно у меня где больше памяти выделится? На хранение ссылки в куче выделяется ли какая-то дополнительная память?**  
  
**Ответ:**  
При хранении `int` в структуре (значимый тип) память выделяется только в стеке для самого значения. Если `int` хранится в классе (ссылочный тип), то в стеке выделяется память для ссылки, а в куче — для самого объекта (включая метаданные). Таким образом, для класса потребуется больше памяти, поскольку используется память и в стеке, и в куче.

---

**00:25:00**  
**Как мы в runtime узнаём, какого типа у нас объект?**  
  
**Ответ:**  
В runtime мы можем узнать реальный тип объекта с помощью оператора `is`, оператора приведения или метода `GetType()`. Например:
```csharp
A obj = new B();
Console.WriteLine(obj.GetType()); // Выведет: B
```
Хотя переменная `obj` имеет тип A, в runtime её реальный тип — B, так как объект был создан через конструктор класса B.

---

**00:30:12**  
**Зачем вообще нам нужна куча?**  
  
**Ответ:**  
Куча нужна для хранения объектов, которые имеют более длительный жизненный цикл и могут быть доступны через несколько методов или потоков. Куча предоставляет возможность динамически выделять память для объектов, размер которых может быть неопределён на этапе компиляции. Это удобно для работы с объектами, ссылки на которые передаются между методами и хранятся дольше, чем текущий стек вызова.

---

**00:31:18**  
**Что за root у нас есть? Которые чистит GC?**  
  
**Ответ:**  
**GC Root** — это стартовые точки, от которых сборщик мусора начинает свой обход объектов в памяти. Если объект может быть достигнут от GC Root, он считается живым и не подлежит сборке. К типичным GC Root относятся:
- Статические поля классов.
- Локальные переменные в стеке.
- Ссылки на объекты, находящиеся в регистрах CPU.
- Параметры методов.

---

**00:33:24**  
**Может ли быть такое, что объект пережил сборку мусора, должен был уйти из 0 поколения, но оказался в 1?**  
  
**Ответ:**  
Да, такое может быть. Если объект переживает первую сборку мусора (в поколении 0), он перемещается в следующее поколение — поколение 1. Это стандартное поведение сборщика мусора: объекты, которые живут дольше, перемещаются в более старшие поколения, так как вероятность их частого удаления снижается.

---

**00:34:30**  
**Деструктор и финализатор**  
  
**Ответ:**  
Деструктор — это метод, который вызывается перед удалением объекта из памяти сборщиком мусора. В C# деструкторы применяются для освобождения неуправляемых ресурсов и записываются как `~ClassName()`. Он автоматически вызывает метод `Finalize()`, который используется для тех же целей.

Деструкторы вызываются не сразу при уничтожении объекта, а на этапе финализации, что может вызвать задержку в освобождении ресурсов. Чтобы избежать этих задержек, рекомендуется использовать интерфейс `IDisposable` и явным образом вызывать

 `Dispose()`.

---

**00:48:30**  
**Зачем нужны индексы в БД?**  
  
**Ответ:**  
Индексы нужны для ускорения поиска данных в таблицах базы данных. Они работают по принципу аналогии с указателями в книгах, позволяя быстро находить строки, соответствующие условиям запроса, без необходимости полного сканирования всей таблицы.

---

**00:48:47**  
**Чем плохи индексы?**  
  
**Ответ:**  
Индексы могут негативно влиять на производительность операций вставки, обновления и удаления, так как при каждой такой операции индексы нужно пересчитывать и обновлять. Также они занимают дополнительное место в памяти.
