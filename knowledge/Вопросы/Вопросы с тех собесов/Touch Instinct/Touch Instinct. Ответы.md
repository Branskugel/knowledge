### ООП

06:40
Есть такая штука, как ООП. Расскажи об одном из принципов.

Ответ:


08:18
Инкапсуляция, часто говорят что это сокрытие, но только ли это сокрытие?

Ответ:


09:54
SOLID. Как понимаешь эти принципы. Зачем их придерживаться и что будет если не придерживаться?

Ответ:


12:02
**Связанность и не связанность**

Ответ:
**Связанность (Coupling)** — это степень зависимости одного модуля от другого. Высокая связанность означает, что изменения в одном модуле могут потребовать изменений в других модулях, что усложняет поддержку и расширение системы. Низкая связанность, наоборот, способствует независимости модулей и упрощает их тестирование и поддержку.

**Не связанность (Cohesion)** — означает, что модули системы минимально зависят друг от друга. Это достигается путём внедрения абстракций, использования интерфейсов и других подходов, таких как внедрение зависимостей. Несвязанность позволяет изменить или заменить один модуль без значительного влияния на другие части системы. Это делает систему более гибкой и поддерживаемой.
### Алгоритмы

12:28
**Алгоритмы сортировки**

Ответ:


14:04
**Работал ли с Хеш таблицами. Что это такое?**

Ответ:
Хеш-таблицы — это структуры данных, которые позволяют хранить пары "ключ-значение" и обеспечивают быстрый доступ к значениям по ключам. В C# существуют несколько реализаций хеш-таблиц:

- **Dictionary**: Основная реализация хеш-таблицы в C#, которая использует дженерики для типизации ключей и значений.
- **HashSet**: Коллекция, которая хранит уникальные элементы и использует хеш-таблицу для быстрого поиска.
- **HashTable**: Устаревшая реализация хеш-таблицы, которая не использует дженерики и не рекомендуется к использованию в новых проектах.


14:56
**Какие плюсы есть у Dictionary, которые определяют что его нужно использовать?**

Ответ:
- **Быстрый доступ**: Dictionary обеспечивает среднее время доступа O(1) для операций добавления, удаления и поиска элементов.
- **Типизация**: Использование дженериков позволяет избежать ошибок, связанных с типами данных, и улучшает читаемость кода.
- **Гибкость**: Dictionary поддерживает различные типы ключей и значений, что делает его универсальным инструментом для хранения данных.
- **Поддержка LINQ**: Dictionary интегрируется с LINQ, что позволяет использовать мощные возможности для работы с коллекциями.
- **Сериализация:** `Dictionary` поддерживает сериализацию, что удобно при передаче данных между различными системами или при их сохранении.

16:12
**Может ли для разных объектов рассчитаться один хэш?**

Ответ:
Да, для разных объектов может рассчитаться один и тот же хэш. Это явление называется коллизией. Коллизии неизбежны, так как количество возможных хэш-значений ограничено, а количество объектов может быть гораздо больше.

16:54
**Если у нас случилось так, что для разных значений рассчитался один хэш, как тогда будет храниться значение? Какие способы есть решения в dotnet?**

Ответ:
Когда происходит коллизия, и два разных значения имеют одинаковый хеш, они хранятся в одной и той же "ячейке" (бакете) хеш-таблицы. В .NET для разрешения коллизий используются следующие методы:

1. **Цепочки (Chaining):** Значения с одинаковым хешем хранятся в виде связного списка в одной ячейке. Этот метод позволяет сохранить все элементы с одинаковым хешем в одной "корзине" и искать их по ключу в этом списке.
    
2. **Открытая адресация (Open Addressing):** Вместо того, чтобы использовать связные списки, при коллизии ищется другая свободная ячейка в таблице, где можно разместить значение.
    

В `Dictionary` используется метод цепочек для разрешения коллизий.

17:52
**У нас есть ключ, по нему мы высчитываем хэш, где мы храним значение, представим что для них расчитался один хеш, мы идём по индексу хеша и смотрим в бакете, получаем оттуда элементы. Как мы можем хранить эти элементы, чтобы нормально резолвить по ключу?**

Ответ:
Можно использовать односвязанный список и по тому списку уже смотреть, какое реально значение мы ищем
### БД

18:57
**С какими базами вообще работал?**

Ответ:


19:56
**Чем отличаются реляционные бд и документоориентированные?**

Ответ:


21:20
**Когда бы ты лично использовал и какую базу?**

Ответ:


22:00
**Работал ли ты с транзакциями в Postrgress?**

Ответ:


23:11
**Уровни изоляции транзакций, зачем они нужны, что это такое?**

Ответ:
Уровни изоляции транзакций определяют, каким образом параллельные транзакции взаимодействуют друг с другом в базе данных. Они задают степень "изоляции" транзакций друг от друга, влияя на вероятность возникновения таких проблем, как грязное чтение, неповторяющееся чтение и фантомные записи. Существуют четыре основных уровня изоляции:

1. **Read Uncommitted (Чтение неподтвержденных данных):** Самый низкий уровень изоляции. Транзакции могут читать данные, которые еще не подтверждены другой транзакцией, что может привести к грязным чтениям.
    
2. **Read Committed (Чтение подтвержденных данных):** Транзакция может читать только те данные, которые были подтверждены другими транзакциями. Это предотвращает грязные чтения, но не защищает от неповторяющихся чтений.
    
3. **Repeatable Read (Повторяемое чтение):** Транзакция, однажды прочитав данные, будет видеть их неизменными до своего завершения, даже если другие транзакции изменили эти данные. Это предотвращает грязные и неповторяющиеся чтения, но не защищает от фантомных записей.
    
4. **Serializable (Сериализуемость):** Самый высокий уровень изоляции. Транзакции выполняются так, как если бы они шли последовательно, одна за другой, что предотвращает все вышеописанные проблемы, но снижает параллелизм и может привести к блокировкам.

23:40
**Могут ли у нас быть проблемы при запуске двух параллельных транзакций?**

Ответ:
Да, при параллельном выполнении двух транзакций могут возникнуть несколько типов проблем:

1. **Грязное чтение (Dirty Read):** Одна транзакция читает данные, измененные другой транзакцией, которая еще не завершена. Если вторая транзакция откатывается, первая транзакция окажется в неконсистентном состоянии.
    
2. **Неповторяющееся чтение (Non-repeatable Read):** Транзакция читает одни и те же данные дважды, но во второй раз получает другой результат, так как другая транзакция изменила данные между чтениями.
    
3. **Фантомные чтения (Phantom Read):** Транзакция повторно выполняет запрос с теми же критериями и получает другой набор строк, потому что другая транзакция добавила или удалила строки.
    
4. **Зависание или взаимная блокировка (Deadlock):** Две транзакции блокируют друг друга, каждая ожидает завершения другой, что приводит к зависанию системы.

24:26
**Приходилось ли тебе работать с индексами?**

Ответ:
Да, индексы — это важный инструмент для оптимизации запросов к базе данных. Они позволяют значительно ускорить операции поиска, сортировки и фильтрации данных. Индексы функционируют как указатели, которые помогают быстро находить нужные данные без необходимости сканировать всю таблицу.

В .NET и других средах разработчики активно используют индексы для оптимизации запросов, особенно в сложных и больших базах данных.

25:44
**На какие типы делятся индексы?**

Ответ:
Индексы делятся на несколько типов в зависимости от их структуры и назначения:

1. **Кластерные индексы (Clustered Indexes)**: Индекс, который определяет физический порядок данных в таблице. В таблице может быть только один кластерный индекс.
2. **Некластерные индексы (Non-clustered Indexes)**: Индекс, который создает отдельную структуру для хранения ключей и указателей на данные. В таблице может быть несколько некластерных индексов.
3. **Уникальные индексы (Unique Indexes)**: Индекс, который гарантирует уникальность значений в столбце или наборе столбцов.
4. **Составные индексы (Composite Indexes)**: Индекс, который включает несколько столбцов.
5. **Полнотекстовые индексы (Full-text Indexes)**: Индекс, который используется для поиска текстовых данных в столбцах.
6. **Фильтрованные индексы (Filtered Indexes)**: Индекс, который создается только для подмножества строк таблицы, удовлетворяющих определенному условию.

26:31
**Кластерные и не кластерные индексы**

Ответ:
**Кластерные индексы (Clustered Indexes)**:

- Определяют физический порядок данных в таблице.
- В таблице может быть только один кластерный индекс.
- Ускоряют операции поиска по ключу индекса.
- Могут замедлить операции вставки и обновления, так как данные должны быть переупорядочены.

**Некластерные индексы (Non-clustered Indexes)**:

- Создают отдельную структуру для хранения ключей и указателей на данные.
- В таблице может быть несколько некластерных индексов.
- Ускоряют операции поиска и сортировки.
- Могут замедлить операции вставки и обновления, так как индексы должны быть обновлены.

### Микросервисы

28:20
**Какие плюсы у микросервисов и какие плюсы у монолитов, когда и что выбирать?**

Ответ:
**Микросервисы:**
- **Масштабируемость**: Каждый микросервис может быть масштабирован независимо от других.
- **Гибкость**: Разные микросервисы могут быть написаны на разных языках программирования и использовать разные технологии.
- **Устойчивость**: Ошибка в одном микросервисе не влияет на другие микросервисы.
- **Разработка и развертывание**: Микросервисы могут быть разработаны, тестированы и развернуты независимо друг от друга.

**Монолиты:**
- **Простота разработки**: Разработка и тестирование монолитного приложения может быть проще, так как все компоненты находятся в одном месте.
- **Производительность**: Внутренние вызовы между компонентами могут быть быстрее, так как они происходят внутри одного процесса.
- **Управление транзакциями**: Легче управлять транзакциями в монолитном приложении, так как все данные находятся в одном месте.

**Когда выбирать микросервисы:**
- Когда у вас есть большая и сложная система, которая требует независимого масштабирования и разработки.
- Когда у вас есть команды, которые могут работать независимо над разными частями системы.
- Когда вам нужна высокая устойчивость и изоляция ошибок.

**Когда выбирать монолиты:**
- Когда у вас есть небольшая или средняя система, которая не требует сложного масштабирования.
- Когда у вас есть ограниченные ресурсы для управления сложностью микросервисной архитектуры.
- Когда вам нужна простота разработки и управления транзакциями.

31:24
**Какие брокеры есть кроме кафки?**

Ответ:
Помимо Apache Kafka, существуют другие брокеры сообщений, такие как:
- **RabbitMQ**: Популярный брокер сообщений, который поддерживает различные модели обмена сообщениями, такие как очереди, топики и публикации/подписки.
- **ActiveMQ**: Брокер сообщений, который поддерживает JMS (Java Message Service) и другие протоколы.
- **Amazon SQS (Simple Queue Service)**: Управляемый сервис очередей сообщений от Amazon Web Services.
- **Azure Service Bus**: Управляемый сервис очередей сообщений от Microsoft Azure.
- **NATS**: Легковесный брокер сообщений, который поддерживает высокую производительность и масштабируемость.

33:44
**CQRS**

Ответ:
CQRS (Command Query Responsibility Segregation) — это архитектурный паттерн, который разделяет операции чтения и записи в приложении. Основные принципы CQRS:

- **Команды (Commands)**: Операции, которые изменяют состояние системы (например, создание, обновление, удаление данных).
- **Запросы (Queries)**: Операции, которые читают данные из системы.

Преимущества CQRS:
- **Масштабируемость**: Разделение чтения и записи позволяет масштабировать эти операции независимо друг от друга.
- **Производительность**: Оптимизация моделей данных для чтения и записи может улучшить производительность.
- **Гибкость**: Разные модели данных для чтения и записи позволяют более гибко управлять данными.

34:58
**Что такое распределённые транзакции?**

Ответ:
Распределённые транзакции — это транзакции, которые охватывают несколько независимых ресурсов, таких как базы данных, очереди сообщений или веб-сервисы. Основные характеристики распределённых транзакций:

- **Атомарность**: Все операции в транзакции должны быть выполнены успешно или ни одна из них не должна быть выполнена.
- **Согласованность**: Транзакция должна переводить систему из одного согласованного состояния в другое.
- **Изоляция**: Операции в транзакции должны быть изолированы от других транзакций.
- **Долговечность**: Результаты транзакции должны быть сохранены даже в случае сбоя системы.

35:12
**Есть Сервис1, есть Сервис2. Сервис1 выполняет какую-то работу, передаёт результат Сервису2 и Сервис2 тоже выполняет работу, но если Сервис2 упал, то изменения в Сервис1 тоже должны откатиться. Вопрос: Как этого можно добиться, какие есть паттерны и решения?**

Ответ:
Для решения этой задачи можно использовать несколько паттернов и решений:
1. **Two-Phase Commit (2PC)**: Этот протокол включает две фазы: подготовку и фиксацию. В фазе подготовки все участники транзакции подтверждают, что они готовы зафиксировать изменения. В фазе фиксации все участники фиксируют изменения. Если хотя бы один участник не может зафиксировать изменения, транзакция откатывается.
    
2. **Saga Pattern**: Этот паттерн используется для управления распределёнными транзакциями в микросервисной архитектуре. Saga разбивает транзакцию на серию шагов, каждый из которых может быть откачен в случае ошибки. Существует два типа Saga:
    - **Choreography-based Saga**: Каждый микросервис управляет своей частью транзакции и отправляет события другим микросервисам для выполнения следующих шагов.
    - **Orchestration-based Saga**: Центральный координатор управляет всей транзакцией и отправляет команды микросервисам для выполнения шагов.

3. **Outbox Pattern**: Этот паттерн используется для обеспечения надежной передачи сообщений между микросервисами. Вместо того чтобы сразу отправлять сообщение в очередь, микросервис сохраняет его в локальной базе данных (outbox). После успешного выполнения транзакции сообщение отправляется в очередь. Если транзакция откатывается, сообщение не отправляется.


36:22
saga и outbox

Ответ:
**Saga Pattern**:
- **Choreography-based Saga (Хореография)**: Каждый микросервис управляет своей частью транзакции и отправляет события другим микросервисам для выполнения следующих шагов. Этот подход децентрализован и требует координации между микросервисами.
- **Orchestration-based Saga (Оркестрация)*: Центральный координатор управляет всей транзакцией и отправляет команды микросервисам для выполнения шагов. Этот подход централизован и упрощает управление транзакцией.

**Outbox Pattern**:
- Этот паттерн используется для обеспечения надежной передачи сообщений между микросервисами. Вместо того чтобы сразу отправлять сообщение в очередь, микросервис сохраняет его в локальной базе данных (outbox). После успешного выполнения транзакции сообщение отправляется в очередь. Если транзакция откатывается, сообщение не отправляется.
- Outbox Pattern обеспечивает атомарность операций и гарантирует, что сообщения будут отправлены только после успешного выполнения транзакции.

Пример использования Outbox Pattern:
```c#
public class OrderService
{
    private readonly IOrderRepository _orderRepository;
    private readonly IMessageQueue _messageQueue;

    public OrderService(IOrderRepository orderRepository, IMessageQueue messageQueue)
    {
        _orderRepository = orderRepository;
        _messageQueue = messageQueue;
    }

    public void PlaceOrder(Order order)
    {
        using (var transaction = _orderRepository.BeginTransaction())
        {
            try
            {
                _orderRepository.SaveOrder(order);
                _orderRepository.SaveOutboxMessage(new OutboxMessage { OrderId = order.Id, Status = "OrderPlaced" });
                transaction.Commit();

                // Отправка сообщения в очередь после успешного выполнения транзакции
                var outboxMessage = _orderRepository.GetOutboxMessage(order.Id);
                _messageQueue.Send(outboxMessage);
            }
            catch
            {
                transaction.Rollback();
                throw;
            }
        }
    }
}

```

### Дотнет

36:42
Что входит в платформу дотнет кроме c#?

Ответ:


37:21
CLR. Расскажи про него

Ответ:


38:50
Net Framework и NetCore, чем они отличаются между собой?

Ответ:


39:40
Interface, зачем они нужны?

Ответ:


40:32
Отличия Interface от абстрактного класса

Ответ:


42:04
Какие есть плюсы и минусы у ORM?

Ответ:
#### Плюсы ORM (Object-Relational Mapping):

1. **Упрощение кода**: ORM позволяет работать с базой данных с помощью объектов и методов, что делает код более читаемым и поддерживаемым.
2. **Абстракция от SQL**: Разработчики могут сосредоточиться на бизнес-логике, а не на написании SQL-запросов.
3. **Переносимость**: Легко переключаться между различными СУБД, так как ORM абстрагирует специфические особенности каждой базы данных.
4. **Безопасность**: ORM помогает избежать SQL-инъекций, так как использует параметризованные запросы.
5. **Производительность**: Некоторые ORM имеют встроенные механизмы кэширования и оптимизации запросов.
#### Минусы ORM:

1. **Производительность**: ORM может быть менее эффективным по сравнению с написанными вручную SQL-запросами, особенно для сложных запросов.
2. **Сложность**: Для сложных запросов и оптимизаций может потребоваться глубокое понимание как ORM, так и SQL.
3. **Ограниченная гибкость**: Некоторые сложные запросы могут быть трудно или невозможно реализовать с помощью ORM.
4. **Накладные расходы**: ORM добавляет дополнительный уровень абстракции, что может увеличить накладные расходы.
5. **Зависимость от ORM**: Переход на другую ORM или отказ от ORM может быть сложным и трудоемким процессом.


43:08 
**Приходилось ли оптимизировать запросы в sql?**

Ответ:


43:33
**Какие есть способы оптимизации запросов sql?**

Ответ:
#### Способы оптимизации запросов SQL:
1. **Индексы**: Создание индексов на часто используемых столбцах может значительно ускорить выполнение запросов.
2. **Оптимизация запросов**: Использование правильных операторов (например, `EXISTS` вместо `IN`), избегание подзапросов, если это возможно.
3. **Анализ плана выполнения**: Использование инструментов для анализа плана выполнения запросов (например, `EXPLAIN` в MySQL) для понимания, где происходят задержки.
4. **Нормализация и денормализация**: Правильная нормализация данных может уменьшить избыточность, а денормализация может ускорить чтение данных.
5. **Кэширование**: Использование кэширования для часто запрашиваемых данных.
6. **Разделение данных**: Разделение больших таблиц на более мелкие части (партиционирование).
7. **Оптимизация JOIN**: Использование правильных типов JOIN и минимизация количества JOIN, если это возможно.

44:06
**Если у нас очень много join, к примеру 20?**

Ответ:
Если у вас очень много JOIN, это может значительно замедлить выполнение запросов. Вот несколько способов оптимизации:

1. **Индексы**: Убедитесь, что все столбцы, используемые в JOIN, имеют индексы.
2. **Разделение запросов**: Разделите сложный запрос на несколько более простых и объедините результаты на уровне приложения.
3. **Денормализация**: Рассмотрите возможность денормализации данных, чтобы уменьшить количество JOIN.
4. **Партиционирование**: Разделите большие таблицы на более мелкие части.
5. **Кэширование**: Используйте кэширование для часто запрашиваемых данных.
6. **Оптимизация структуры данных**: Пересмотрите структуру данных и схему базы данных для уменьшения количества JOIN.

44:34
**Если запрос выполняется минуту, это проблема, что можно сделать чтобы оптимизировать его?**

Ответ:


46:43
Есть в dotnet тип string, чем она особенна? Как работает StringBuilder

Ответ:


48:42
Как работают List?

Ответ:


49:20
**Какой тип имеет string?**

Ответ:
В C# тип `string` является ссылочным типом. Он представляет собой неизменяемую последовательность символов Unicode. Это означает, что после создания строки её содержимое не может быть изменено. Любые операции, которые изменяют строку, создают новую строку.

50:02
**Как хранится любой массив?**

Ответ:
Массивы в C# хранятся в памяти как непрерывные блоки данных. Каждый элемент массива имеет фиксированный размер и индекс, который указывает на его позицию в массиве. Массивы в C# являются ссылочными типами, что означает, что переменная массива хранит ссылку на область памяти, где хранятся элементы массива.

50:34 
**Что такое переменная?**

Ответ:
Переменная в C# — это именованная область памяти, которая используется для хранения данных. Переменная имеет тип, который определяет, какие значения она может хранить, и имя, которое используется для доступа к этой области памяти. Переменные могут быть значимыми типами (например, `int`, `double`) или ссылочными типами (например, `string`, `object`).

51:20
**Как у нас хранятся значимые типы?**

Ответ:


52:25
**Приходилось ли работать с асинхронным кодом?**

Ответ:


53:08
**Чем отличается асинхронный код от синхронного?**

Ответ:


53:18
**Зачем мы используем асинхронный код?**


Ответ:




