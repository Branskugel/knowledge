**00:17:26** 
**Какую проблему решаем с помощью асинхронных методов?**

**Ответ:** 
Асинхронные методы решают проблему блокировки основного потока при выполнении длительных операций, таких как запросы к базе данных, сетевые операции и файловый ввод-вывод. Это позволяет более эффективно использовать ресурсы системы, избегая блокировки потоков на ожидание завершения операций, и обеспечивает лучшую отзывчивость приложений, особенно в контексте UI-приложений.

**00:20:20** 
**С какими примитивами синхронизации знакомы и работали?**

**Ответ:**  
- **lock (Monitor)** — для блокировки критических секций кода.
- **Semaphore и SemaphoreSlim** — для ограничения количества потоков, которым разрешён доступ к ресурсу.
- **Mutex** — для синхронизации между процессами.
- **ReaderWriterLockSlim** — для организации доступа к ресурсам с разделением на операции чтения и записи.
- **ManualResetEvent/AutoResetEvent** — для сигнализации между потоками.

**00:22:25** 
**Мы не можем async await использовать в принципе в локах или только в каких-то определённы ситуациях?** 

**Ответ:** 
Использование `async` и `await` внутри блоков `lock` может привести к проблемам, таким как блокировка потоков и потенциальные deadlocks. Вместо этого рекомендуется использовать асинхронные примитивы синхронизации, такие как `SemaphoreSlim`, `Mutex`, или `AsyncLock` из сторонних библиотек.

Однако с помощью асинхронного программирования часто используется `SemaphoreSlim`, который поддерживает асинхронное ожидание с помощью метода `WaitAsync`, что позволяет избежать блокировок при ожидании и использовать `async`/`await`.
  

**00:23:15**  
**Расскажи про параллельные коллекции, какие знаешь, с какими работал и какие лучше использовать, с примерами.**

**Ответ:**  
Параллельные коллекции предоставляют потоко-безопасные операции над данными без необходимости ручной синхронизации. Примеры параллельных коллекций:

- **ConcurrentDictionary** — потоко-безопасная версия `Dictionary`, которая позволяет безопасно выполнять операции добавления, удаления и обновления из нескольких потоков.
- **ConcurrentQueue и ConcurrentStack** — аналоги очереди и стека, которые поддерживают многопоточные операции.
- **BlockingCollection** — используется для организации очередей с поддержкой блокировки и предела вместимости. Часто применяется в сценариях «производитель-потребитель».

Пример использования `ConcurrentDictionary`:

```c#
var concurrentDictionary = new ConcurrentDictionary<int, string>(); concurrentDictionary.TryAdd(1, "One");
concurrentDictionary.TryGetValue(1, out var value);
```

**00:24:17**  
**Если я хочу атомарно увеличить какое-то значение какого-то поля и поменять значения местами, как я могу это сделать? С помощью какого класса?**

**Ответ:**  
Для атомарного увеличения значений используется класс **Interlocked**. Он поддерживает атомарные операции над примитивными типами данных, такими как `int`, `long`, и ссылками. Для изменения местами значений можно использовать метод `Interlocked.Exchange`.

Пример:
```c#
int value = 0;
Interlocked.Increment(ref value); // Атомарное увеличение значения

int a = 5;
int b = 10;
int temp = Interlocked.Exchange(ref a, b); // Обмен значений местами

```

  
**00:25:05**  
**Расскажи про dispose паттерн, что зачем, какую проблему с ним решаем**

**Ответ:**  
Dispose паттерн используется для освобождения неуправляемых ресурсов (файловые дескрипторы, сетевые соединения и т.д.). В C# для этого реализуется интерфейс `IDisposable`, который предоставляет метод `Dispose`, где мы должны освобождать такие ресурсы.

Основная проблема, которую решает Dispose паттерн — это своевременное освобождение неуправляемых ресурсов, чтобы избежать утечек памяти.

Пример реализации:
```c#
public class ResourceHolder : IDisposable
{
    private bool disposed = false;

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождение управляемых ресурсов
            }
            // Освобождение неуправляемых ресурсов
            disposed = true;
        }
    }

    ~ResourceHolder()
    {
        Dispose(false);
    }
}

```

  
**Какие есть ситуации, которые грозят утечкой памяти? Если не брать в расчёт не защищённый код, а только safe.**

**Ответ:**  
Даже в безопасном коде возможны утечки памяти из-за:

- **Неосвобожденных неуправляемых ресурсов** — если не реализован или некорректно реализован `Dispose`.
- **События и делегаты** — если подписчики не отписаны от событий, объекты не будут сборщиками мусора корректно убираться.
- **Статические ссылки** — если объекты ссылаются на статические поля или события, сборщик мусора не сможет их освободить.
- **Кеширование** — чрезмерное или неконтролируемое кеширование данных может привести к росту потребляемой памяти.
  

**00:30:50** **Расскажи про di контейнеры**

**Ответ:** DI (Dependency Injection) контейнеры используются для управления зависимостями в приложении. Они автоматически создают и внедряют зависимости в классы, что упрощает тестирование и поддержку кода. Популярные DI контейнеры в .NET включают `Microsoft.Extensions.DependencyInjection`, `Autofac`, `Ninject`, `Unity`. Пример использования `Microsoft.Extensions.DependencyInjection`:

```c#
var serviceCollection = new ServiceCollection(); serviceCollection.AddTransient<IMyService, MyService>(); var serviceProvider = serviceCollection.BuildServiceProvider(); var myService = serviceProvider.GetService<IMyService>();
```

**00:31:42** **Расскажите с какими бд работали**

**Ответ:** Я работал с различными базами данных, включая реляционные и NoSQL базы данных. Среди них:

- **PostgreSQL**: Мощная реляционная база данных с открытым исходным кодом.
- **MongoDB**: NoSQL база данных, используемая для хранения документов.
- **SQLite**: Легковесная реляционная база данных, часто используемая для встраиваемых систем.


**00:33:02** 
**Что можете рассказать про индексы в бд, что это такое, зачем они нужны?**

**Ответ:** 
Индексы в базах данных — это структуры данных, которые улучшают производительность операций поиска и сортировки. ни позволяют быстрее находить записи, не проходя через всю таблицу. Индексы строятся на столбцах, по которым часто выполняются запросы. Однако, у них есть и недостатки — создание и поддержка индексов увеличивают объём хранимых данных и могут замедлять операции вставки, удаления и обновления. Индексы создаются на основе одного или нескольких столбцов таблицы и позволяют базе данных быстрее находить нужные записи. Основные типы индексов включают:

- **Кластерные индексы**: Определяют физический порядок данных в таблице.
- **Некластерные индексы**: Создают отдельную структуру для ускорения поиска, не изменяя порядок данных в таблице.
- **Уникальные индексы**: Гарантируют уникальность значений в индексированных столбцах. Индексы особенно полезны для ускорения выполнения запросов, но их использование требует баланса, так как они могут замедлить операции вставки, обновления и удаления данных.

Пример создания индекса:
```SQL
CREATE INDEX idx_column_name ON table_name (column_name);
```

Вот примеры создания каждого типа индекса:
### B-tree индекс

B-tree индексы являются наиболее распространенными и подходят для большинства типов запросов. Они поддерживают операции сравнения (=, <, >, <=, >=, BETWEEN, IN, IS NULL).

`CREATE INDEX idx_btree ON your_table (your_column);`

### Hash индекс

Hash индексы подходят для точных поисков (=) и могут быть быстрее B-tree индексов для таких запросов.

`CREATE INDEX idx_hash ON your_table USING HASH (your_column);`

### GiST индекс

GiST (Generalized Search Tree) индексы подходят для сложных запросов, таких как полнотекстовый поиск, геометрические запросы и другие.

`CREATE INDEX idx_gist ON your_table USING GIST (your_column);`

### GIN индекс

GIN (Generalized Inverted Index) индексы также подходят для полнотекстового поиска и других сложных запросов.

`CREATE INDEX idx_gin ON your_table USING GIN (your_column);`

### BRIN индекс

BRIN (Block Range INdex) индексы подходят для больших таблиц, где данные упорядочены физически.

`CREATE INDEX idx_brin ON your_table USING BRIN (your_column);`

### Примеры создания индексов

Предположим, у вас есть таблица `employees` с колонками `id`, `name`, `age` и `department`.

#### B-tree индекс

`CREATE INDEX idx_employees_name ON employees (name);`

#### Hash индекс

`CREATE INDEX idx_employees_id ON employees USING HASH (id);`

#### GiST индекс

`CREATE INDEX idx_employees_age ON employees USING GIST (age);`

#### GIN индекс

`CREATE INDEX idx_employees_department ON employees USING GIN (department);`

#### BRIN индекс

`CREATE INDEX idx_employees_id_brin ON employees USING BRIN (id);`

### Заключение

Выбор типа индекса зависит от конкретных требований вашего приложения и типов запросов, которые вы планируете выполнять. B-tree индексы являются универсальными и подходят для большинства случаев, тогда как другие типы индексов могут быть более эффективными для специфических задач.