**00:20:26**  
**Видел ли ты во что превращается код CLR**  
  
**Ответ:**  
Да, код, который компилируется под CLR (Common Language Runtime), сначала преобразуется в промежуточный код, называемый **IL (Intermediate Language)**. Этот код затем выполняется JIT-компилятором (Just-In-Time), который преобразует IL в машинный код непосредственно перед выполнением. В итоге, код становится нативным для операционной системы и может эффективно выполняться процессором.

---

**00:20:30**  
**Что такое CLR**  
  
**Ответ:**  
CLR (Common Language Runtime) — это виртуальная машина, которая является частью .NET Framework и .NET Core. Она управляет выполнением .NET-программ, обеспечивая такие функции, как сборка мусора (GC), управление памятью, обработка исключений, безопасность, а также поддержку работы с многопоточностью и синхронизацией. CLR является средой выполнения для всех .NET-языков, таких как C#, VB.NET и F#.

---

**00:33:58**  
**Что такое память и как мы с ней работаем. Управляемая и неуправляемая память. Как мы работаем в потоках с памятью.**  
  
**Ответ:**  
Память — это область хранения данных, используемая приложениями для выполнения их операций. В .NET существует разделение на управляемую и неуправляемую память:
- **Управляемая память** — память, которая автоматически управляется CLR с помощью сборщика мусора (GC). Программисты не занимаются ручным выделением и освобождением управляемой памяти, сборщик мусора автоматически освобождает её, когда объекты больше не используются.
- **Неуправляемая память** — это память, выделяемая непосредственно операционной системой или через библиотеки, которая не управляется CLR. Работа с ней требует ручного управления (например, через вызовы `Marshal` или работу с API низкого уровня). 

В многопоточном окружении доступ к памяти должен быть синхронизирован, чтобы избежать гонок данных. Для этого применяются различные примитивы синхронизации (например, `lock`, `Monitor`, `Mutex` и т.д.).

---

**00:36:06**  
**Режимы работы GC. Station, server.**  
  
**Ответ:**  
В .NET существует несколько режимов работы сборщика мусора (GC):
- **Workstation GC** — используется в приложениях с пользовательским интерфейсом, оптимизирован для низкой задержки и хорошей отзывчивости UI. Он работает на одном ядре процессора и подходит для однопоточных приложений.
- **Server GC** — предназначен для серверных приложений, где важна высокая производительность и используются многопроцессорные системы. В этом режиме GC работает параллельно на нескольких ядрах, что повышает пропускную способность при большом числе потоков и больших объёмах памяти.

---

**00:38:03**  
**Как получается, что у нас объекты лежат в разных поколениях, для чего нужны эти поколения?**  
  
**Ответ:**  
Поколения в сборщике мусора (GC) используются для оптимизации процесса управления памятью. Объекты распределяются по трём поколениям:
- **Поколение 0** — для краткоживущих объектов, которые собираются чаще всего.
- **Поколение 1** — используется для объектов средней продолжительности жизни.
- **Поколение 2** — для долгоживущих объектов.

Эта система работает на основе того, что многие объекты "умирают" быстро, и если объект пережил несколько сборок мусора, его перемещают в более старшее поколение. Таким образом, сборщик мусора экономит ресурсы, реже проверяя долгоживущие объекты.

---

**00:39:21**  
**Что такое дефрагментация памяти в GC.**  
  
**Ответ:**  
Дефрагментация памяти в GC — это процесс уплотнения объектов в управляемой памяти после сборки мусора. Когда сборщик мусора освобождает неиспользуемые объекты, в памяти могут оставаться "дырки". Чтобы избежать фрагментации и сделать память непрерывной, объекты перемещаются в смежные области, что улучшает производительность и уменьшает вероятность ошибок при распределении новых объектов.

---

**00:39:21**  
**У нас есть два приложения, одно на C#, другое на C++, и тебе нужно не через память и не через API взаимодействовать с одним и тем же объектом в памяти. И есть такое понятие как маршалинг. Что это и как с ним работать? Где это работает?**  
  
**Ответ:**  
**Маршалинг** — это процесс преобразования данных из управляемой среды .NET (C#) в неуправляемую (например, C++) и обратно. Он необходим для взаимодействия между кодом, работающим в различных средах, например, при использовании P/Invoke или COM.

Маршалинг используется для работы с неуправляемыми ресурсами (как правило, в Windows через `DllImport`), а также для взаимодействия с внешними библиотеками или системами, написанными на других языках, таких как C++.

Пример маршалинга для вызова C++ функции из C#:
```csharp
[DllImport("NativeLibrary.dll")]
public static extern int NativeFunction(int param);
```

Это работает преимущественно в Windows, так как поддерживает взаимодействие с неуправляемым кодом в Win32 API.

---

**00:39:21**  
**Что такое БД, что такое ACID**  
  
**Ответ:**  
БД (база данных) — это система для хранения, управления и извлечения данных. ACID — это набор свойств, которые обеспечивают надёжность транзакций в базах данных:
- **Atomicity (Атомарность)** — транзакция выполняется целиком или не выполняется вовсе.
- **Consistency (Согласованность)** — после завершения транзакции данные остаются в согласованном состоянии.
- **Isolation (Изолированность)** — параллельные транзакции не влияют друг на друга.
- **Durability (Надёжность)** — после подтверждения транзакции её изменения сохраняются даже в случае сбоя системы.

---

**00:47:44**  
**Как сама PostgreSQL обеспечивает атомарность транзакций?**  
  
**Ответ:**  
PostgreSQL обеспечивает атомарность транзакций с помощью **журналирования WAL (Write-Ahead Logging)**. Перед тем как транзакция завершится, все изменения записываются в журнал. Если во время транзакции произойдёт сбой (например, отключение питания), при перезапуске PostgreSQL использует журнал для восстановления состояния базы данных и доведения незавершённых операций до конца либо отката их полностью. Это позволяет гарантировать, что данные либо будут полностью записаны, либо не будут изменены вовсе.

---

**00:39:21**  
**Влияет ли как-то механизм мультиверсионности на изоляцию транзакций в PostgreSQL? Как изоляция транзакций обеспечивается в PostgreSQL.**  
  
**Ответ:**  
Да, механизм **MVCC (Multiversion Concurrency Control)** в PostgreSQL напрямую влияет на изоляцию транзакций. Этот механизм позволяет нескольким транзакциям одновременно работать с одной и той же таблицей, создавая "снимки" данных на момент начала каждой транзакции. Благодаря MVCC, транзакции могут читать данные без блокировок, даже если другие транзакции изменяют те же данные.

Изоляция транзакций в PostgreSQL обеспечивается уровнями изоляции:
- **Read Uncommitted**
- **Read Committed**
- **Repeatable Read**
- **Serializable**

MVCC позволяет уменьшить конфликты и блокировки при чтении данных, повышая производительность работы с многопоточными транзакциями.

---

**00:52:28**  
**Что ты знаешь про индексы в PostgreSQL?**  
  
**Ответ:**  
Индексы в PostgreSQL — это структуры данных, которые ускоряют поиск строк в таблицах. PostgreSQL поддерживает несколько типов индексов, таких как **B-tree**, **Hash**, **GiST**, **GIN**, и **BRIN**, каждый из которых оптимален для разных типов запросов. Индексы ускоряют выполнение запросов, таких как `SELECT`, за счёт сокращения числа строк, которые нужно просматривать, но могут замедлить операции вставки, обновления и удаления, так как индексы также должны быть обновлены.

---

**00:53:56**  
**У нас есть таблица, колонка, мы на колонку вешаем индекс. В каких ситуациях индекс не даст прирост или вообще замедлит работу.**  
  
**Ответ:**  
Индекс может не дать прироста производительности или замедлить работу в таких ситуациях:
- **Когда запрос выбирает большую часть данных таблицы**, обычно более 20-30%. В таких случаях может быть быстрее выполнить полный скан таблицы, чем использовать индекс.
- **При частых вставках, обновлениях и удалениях** — индексы требуют дополнительного времени для обновления.
- **Функции и операции, которые игнорируют индексы**, например, функции, изменяющие значения, как `LOWER()` без использования выражений для создания индекса на результатах этих функций.

---

**00:55:44**

  
**Что такое покрывающий индекс? Covering index**  
  
**Ответ:**  
Покрывающий индекс — это индекс, который содержит все данные, необходимые для выполнения запроса, что позволяет обойтись без обращения к самой таблице. Это снижает количество операций чтения с диска и ускоряет запросы. Пример создания покрытия для запроса, который выбирает несколько столбцов:
```sql
CREATE INDEX idx_covering ON table_name (column1, column2);
```
Если запрос использует только `column1` и `column2`, то все данные будут получены непосредственно из индекса.

---

**00:57:07**  
**Что такое IQueryable, что такое отложенное выполнение? Как с этим работать? И для чего это нужно?**  
  
**Ответ:**  
`IQueryable` — это интерфейс, представляющий запрос к источнику данных, который может быть построен динамически и выполнен на стороне базы данных. Основное отличие от `IEnumerable` в том, что `IQueryable` поддерживает **отложенное выполнение** (Lazy Loading), то есть запрос не выполняется немедленно, а откладывается до тех пор, пока не будет произведена итерация или вызван метод, который требует выполнения (например, `ToList()`).

Отложенное выполнение позволяет эффективно строить и оптимизировать запросы, выполняя их только тогда, когда это необходимо, и позволяет объединять запросы для их оптимального выполнения.

Пример:
```csharp
IQueryable<Customer> query = dbContext.Customers.Where(c => c.Age > 30);
var result = query.ToList(); // запрос выполняется только здесь
```