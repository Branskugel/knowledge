**5:33**
**Как у вас устроен CI|CD и какие инструменты для этого используйте?**

Ответ:
1. **Инструменты**:
    - **GitLab CI/CD**: Для автоматизации процессов сборки, тестирования и развертывания.
    - **Docker**: Для контейнеризации микросервисов.
    - **Kubernetes**: Для оркестрации контейнеров.
    - **Helm**: Для управления Kubernetes-приложениями.
    - **NUnit**: Для написания и выполнения тестов.

**СI/CD Pipeline**
1. **Инструменты**:
    - **GitLab CI/CD**: Для автоматизации процессов сборки, тестирования и развертывания.
    - **Docker**: Для контейнеризации микросервисов.
    - **Kubernetes**: Для оркестрации контейнеров.
    - **Helm**: Для управления Kubernetes-приложениями.
    - **NUnit**: Для написания и выполнения автоматических тестов.
    - **JIRA**: Для управления задачами и отслеживания ошибок.
    - **TestRail**: Для управления ручным тестированием.

1. **CI/CD Pipeline**:
    - **Сборка**:
        - Код из GitLab репозитория клонируется на CI/CD сервер.
        - Выполняется сборка проекта с использованием .NET SDK.
        - Создаются Docker-образы для каждого микросервиса.
    - **Тестирование**:
        - Выполняются автоматические тесты с использованием NUnit.
        - Проводится статический анализ кода.
        - Выполняются интеграционные тесты.
    - **Развертывание в тестовое окружение**:
        - Docker-образы публикуются в Docker Registry.
        - Обновляются Helm-чарты для Kubernetes.
        - Выполняется развертывание в тестовое окружение.
        - Уведомляются ручные тестировщики о новом развертывании.
    - **Ручное тестирование**:
        - Ручные тестировщики проводят тестирование в тестовом окружении.
        - Результаты тестирования записываются в TestRail.
        - Создаются задачи в JIRA для исправления ошибок.
    - **Развертывание в продакшн**:
        - После успешного ручного тестирования и исправления всех ошибок, код развертывается в продакшн-окружение.

##### Заключение
Микросервисная архитектура с использованием RESTful API и Kafka позволяет эффективно организовать взаимодействие между сервисами. CI/CD процесс с использованием GitLab CI/CD, Docker, Kubernetes и Helm обеспечивает автоматизацию сборки, тестирования и развертывания приложений, что повышает производительность и надежность системы.

**7:00**
**Флоу выполнения задач, как вам задача выпадает, как ты её начинаешь разрабатывать, как тестируйте и как выводите в прод?**

Ответ:


**10:08**
**Подробнее рассказать про тестирование. Пишите ли unit тесты, интеграционные тесты, как происходит передача в тесты и как происходит взаимодействие между тестировщиками и разработчиками.**

Ответ:


#### Dotnet
##### Base

12:00
**Расскажи про ссылочные и значимые типы. Для чего они нужны, какая между ними разница**

Ответ:
В C# ссылочные типы (reference types) и значимые типы (value types) отличаются тем, как они хранятся в памяти и как передаются между методами. Значимые типы, такие как `int`, `float`, `struct`, хранятся в стеке и передаются по значению, что означает, что при передаче в метод создается копия этого значения.

Ссылочные типы, такие как `class`, `string`, `object`, хранятся в куче и передаются по ссылке. Это значит, что при передаче в метод передается ссылка на область памяти, где находится объект, а не его копия. Соответственно, изменения в объекте внутри метода будут видны и вне метода.

1. **Ссылочные типы**:
    - Хранятся в куче (heap).
    - Переменные ссылочных типов содержат ссылки на объекты в куче.
    - Примеры: классы, интерфейсы, строки.
    - Присваивание одной переменной другой приводит к копированию ссылки, а не самого объекта.
    
1. **Значимые типы**:
    
    - Хранятся в стеке (stack).
    - Переменные значимых типов содержат сами значения.
    - Примеры: структуры, перечисления, базовые типы (int, double, bool и т.д.).
    - Присваивание одной переменной другой приводит к копированию значения.

14:44
**Может ли быть такое, что значимые типы оказываются в кучи, а ссылочные типы оказываются в стеке?**

Ответ:
1. **Значимые типы в куче**:
    - Да, значимые типы могут оказаться в куче, если они являются частью ссылочного типа. Например, если структура является полем класса, то она будет храниться в куче вместе с объектом класса.

1. **Ссылочные типы в стеке:**
    - Нет, ссылочные типы не могут храниться в стеке. Ссылки на объекты ссылочных типов могут храниться в стеке, но сами объекты всегда хранятся в куче.

17:50
**Как очищаются данные в стеке?**

Ответ:
Данные в стеке очищаются автоматически по мере выхода из области видимости. Когда метод завершает выполнение, его стековые фреймы уничтожаются, и место, занимаемое локальными переменными и значимыми типами, освобождается. Это происходит благодаря механизму управления стеком, который отслеживает начало и конец каждого вызова метода, и происходит быстро и эффективно, так как стек работает по принципу LIFO (последний зашел — первый вышел).

19:10
**ref и out. В чём отличия передачи в методы, когда параметры помечаются этими ключевыми словами?**

Ответ:
Ключевые слова `ref` и `out` используются для передачи параметров по ссылке, но есть некоторые отличия:

- `ref` требует, чтобы переменная была инициализирована до передачи в метод, поскольку метод может как читать, так и записывать значение.
    
- `out` не требует инициализации переменной перед передачей, но метод обязан присвоить ей значение до завершения. `out` обычно используется для возвращения нескольких значений из метода.

1. **ref**:
    - Параметр должен быть инициализирован перед передачей в метод.
    - В методе можно изменять значение параметра.
    - Пример: `void Method(ref int x) { x = 10; }`
    
1. **out**:
    - Параметр не обязательно инициализировать перед передачей в метод.
    - В методе обязательно нужно присвоить значение параметру перед возвратом.
    - Пример: `void Method(out int x) { x = 10; }`


**21:50**
**Какой объём стека и кучи?** 

Ответ:
Размер стека обычно ограничен и зависит от конкретной среды выполнения. В .NET по умолчанию стек каждого потока имеет размер около 1 МБ, но это значение может быть изменено. Объем кучи зависит от доступной памяти в системе и от конфигурации среды выполнения .NET. Куча используется для динамического распределения памяти, и её объем может значительно варьироваться в зависимости от нагрузки и типа приложения.

1. **Стек**:
    
    - У каждого потока свой отдельный стек.
    - Размер стека по умолчанию составляет 1 МБ, но его можно изменить при создании потока.
2. **Куча**:
    
    - Размер кучи динамически управляется сборщиком мусора (Garbage Collector).
    - Куча может увеличиваться или уменьшаться в зависимости от потребностей приложения.

22:03
**По количеству этих структур, сколько их может быть?**

Ответ:
У каждого потока свой отдельный стек, и количество стеков соответствует количеству потоков. Обычно стек ограничен по размеру до 1 МБ для каждого потока, но в некоторых случаях, как в многопоточных приложениях, размер стека может быть изменен при создании потока.

Куча, наоборот, общая для всех потоков и размер её динамически изменяется. В .NET среде может быть несколько куч, особенно в контексте сборщика мусора (например, большая куча объектов, поколения и так далее), но это более глубокая тема.

1. **Стек**:
    
    - У каждого потока свой отдельный стек.
    - Количество стеков равно количеству потоков в приложении.
2. **Куча**:
    
    - В .NET существует одна куча, управляемая сборщиком мусора.
    - Куча разделена на несколько поколений (Generation 0, 1, 2 и Large Object Heap), которые помогают оптимизировать процесс сборки мусора.

##### GC

23:36
**Как устроен сборщик мусора?**

Ответ:
Сборщик мусора (Garbage Collector, GC) в .NET отвечает за автоматическое управление памятью. Он освобождает память, занятую объектами, которые больше не используются приложением. GC работает по принципу "три поколения": Generation 0, Generation 1 и Generation 2.

- **Generation 0** — сюда попадают новые объекты. Когда память в Generation 0 заполняется, GC запускает сборку мусора, освобождая неиспользуемые объекты и перемещая оставшиеся в Generation 1.

- **Generation 1** — используется как буфер между Generation 0 и Generation 2. Объекты, которые пережили несколько циклов сборки мусора, перемещаются сюда.

- **Generation 2** — здесь находятся долгоживущие объекты, которые редко изменяются. Сборка мусора на этом уровне запускается реже, поскольку она более затратная по времени.

- **Large Object Heap (LOH)**: Содержит большие объекты (более 85 КБ). Сборка мусора в LOH происходит реже и отдельно от других поколений.

**Алгоритм сборки мусора**:
- GC использует алгоритм "Mark-and-Sweep" для определения живых и мертвых объектов.
- В процессе сборки мусора GC приостанавливает выполнение всех потоков (Stop-the-World), чтобы избежать изменений в состоянии объектов.

**Фазы сборки мусора**:
- **Marking Phase**: GC отмечает все достижимые объекты.
- **Relocation Phase**: GC перемещает живые объекты в компактную область памяти.

25:23
**Как сборщик понимает, что эти объекты используются, а эти нет?**

Ответ:
GC определяет, какие объекты используются, а какие нет, с помощью алгоритма "Mark-and-Sweep":

1. **Roots**:
    - GC начинает с корней (roots), которые включают в себя глобальные и статические объекты, локальные переменные и параметры методов, а также объекты, на которые ссылаются регистры процессора.
    
1. **Marking Phase**:
    - GC проходит по всем корням и отмечает все объекты, на которые они ссылаются.
    - Затем GC проходит по всем отмеченным объектам и отмечает все объекты, на которые они ссылаются, и так далее, пока не будут отмечены все достижимые объекты.
    
1. **Sweep Phase**:
    - Все объекты, которые не были отмечены, считаются мертвыми и их память освобождается.

26:20
Расскажи про dispose и финализацию

Ответ:
`IDisposable` и метод `Dispose` используются для явного освобождения неуправляемых ресурсов, таких как файловые дескрипторы, соединения с базами данных и так далее. Реализация интерфейса `IDisposable` позволяет разработчику вручную управлять временем освобождения ресурсов, не дожидаясь запуска GC.

Метод `Dispose` вызывается явно в коде, обычно с помощью конструкции `using` или вручную.

Пример:
```c#
public class MyClass : IDisposable
{
    public void Dispose()
    {
        // Освобождение ресурсов
    }
}
```

Финализация (деструктор) — это метод `Finalize`, который вызывается сборщиком мусора перед удалением объекта из памяти. Финализация используется для освобождения неуправляемых ресурсов, если объект не был явно освобожден. Однако финализация не гарантируется, так как GC может быть не вызван, или процесс может завершиться до вызова финализатора.

Пример:
```c#
public class MyClass
{
    ~MyClass()
    {
        // Освобождение ресурсов
    }
}
```

28:41
**Для чего писать dispose, если можно реализовать деструктор и переложить всю ответственность на сборщик мусора?**

Ответ:
Написание метода `Dispose` и реализация интерфейса `IDisposable` дает более точный контроль над управлением ресурсами, что позволяет избежать задержек и неопределенности, связанных с финализацией. Финализаторы работают медленнее и увеличивают нагрузку на GC, поскольку требуют дополнительных ресурсов для своего выполнения. Использование `Dispose` позволяет освобождать ресурсы немедленно, что повышает производительность приложения и снижает риск утечек памяти.

1. **Детерминированное освобождение ресурсов**:
    - Метод `Dispose` позволяет освобождать ресурсы детерминированно, то есть в точно определенное время, когда это необходимо.
    - Финализатор вызывается недетерминированно, когда сборщик мусора решит, что объект больше не используется.

1. **Производительность**:
    - Вызов `Dispose` позволяет освобождать ресурсы сразу, что может быть критично для производительности приложения.
    - Финализатор может вызываться с задержкой, что может привести к утечкам ресурсов и снижению производительности.

1. **Паттерн Dispose**:
    - Рекомендуется использовать паттерн Dispose, который включает в себя как метод `Dispose`, так и финализатор.
    - Пример:
```c#
public class MyClass : IDisposable
{
    private bool disposed = false;

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Освобождение управляемых ресурсов
            }
            // Освобождение неуправляемых ресурсов
            disposed = true;
        }
    }

    ~MyClass()
    {
        Dispose(false);
    }
}

```



29:33
**Знаешь что-то про очереди финализации?**

Ответ:
Да, в .NET существует специальная очередь финализации (finalization queue), в которую попадают объекты с реализованным методом `Finalize`. Когда объект попадает в эту очередь, он не будет удален сборщиком мусора до тех пор, пока его метод `Finalize` не выполнится. После выполнения `Finalize` объект перемещается в очередь для удаления (freachable queue), и сборщик мусора освобождает его память при следующем проходе.

##### Многопоточность

30:20 
**Что такое параллизм и асинхронность** 

Ответ:
Для **асинхронности** достаточно одного ядра. Асинхронность не требует выполнения задач параллельно, а использует механизм переключения контекста, что позволяет эффективно управлять временем выполнения задач.

Для **параллелизма** требуется как минимум два ядра, чтобы задачи могли выполняться одновременно. Чем больше ядер, тем больше задач могут выполняться параллельно, но для работы параллелизма необходимо хотя бы одно ядро на каждую задачу.

1. **Параллелизм**:
    - Параллелизм — это выполнение нескольких задач одновременно на нескольких ядрах процессора.
    - Пример: Выполнение нескольких потоков одновременно на многоядерном процессоре.

1. **Асинхронность**:
    - Асинхронность — это выполнение задач, которые не блокируют основной поток выполнения.
    - Пример: Выполнение I/O операций (например, чтение файла или запрос к сети) без блокировки основного потока.

32:00
Сколько ядер нужно чтобы работала асинхронность и параллизм?

Ответ:
1. **Асинхронность**:
    - На одноядерном процессоре асинхронность работает за счет переключения контекста (context switching).
    - Основной поток выполнения не блокируется и может продолжать выполнять другие задачи, пока асинхронная операция выполняется в фоновом режиме.
    
1. **Параллелизм**:
    - На одноядерном процессоре параллелизм невозможен, так как задачи будут выполняться последовательно.
    - Операционная система может переключать контекст между потоками, создавая иллюзию параллелизма, но фактически задачи выполняются последовательно.

33:13
Как тогда работает на одноядерном процессоре?

Ответ:


34:38
**Синхронизация потоков.** 
**Что это за штука?**
**Зачем она нужна?**
**Как решается?**

Ответ:
1. **Синхронизация потоков**:
    
    - Синхронизация потоков — это механизм, который позволяет координировать выполнение нескольких потоков, чтобы избежать конфликтов и обеспечить корректное выполнение программы.
2. **Зачем она нужна**:
    
    - Синхронизация необходима для предотвращения состояний гонки (race conditions), когда несколько потоков пытаются одновременно изменять общие данные.
3. **Как решается**:
    
    - Использование примитивов синхронизации, таких как `lock`, `Monitor`, `Mutex`, `Semaphore`, `SemaphoreSlim`, `ManualResetEvent`, `AutoResetEvent` и другие.

Решается это с помощью различных синхронизирующих примитивов, таких как `lock`, `Mutex`, `Semaphore`, `Monitor`, `ManualResetEvent`, `AutoResetEvent`. Эти примитивы обеспечивают эксклюзивный доступ к ресурсам и координируют порядок выполнения потоков.

```c#
private readonly object _lock = new object();

public void SomeMethod()
{
    lock (_lock)
    {
        // Критическая секция
    }
}
```


36:30
**При использовании lock, нужно применить какой-нибудь объект, обязательно ссылочного типа, почему так?**

Ответ:
Объект, используемый в `lock`, должен быть ссылочного типа, потому что ссылочные типы обеспечивают уникальный идентификатор объекта в куче. `lock` блокирует доступ к определенному блоку кода на основе ссылочной идентификации объекта. Если бы использовались значимые типы, при каждом использовании создавалась бы новая копия объекта, что нарушало бы механизм синхронизации, так как каждый поток блокировал бы свою копию.

37:10
**Есть такое ограничение lock-a, что внутри нельзя использовать асинхронный код, можешь предположить почему такое ограничение существует?**

Ответ:
Ограничение на использование асинхронного кода внутри `lock` связано с тем, что `lock` блокирует текущий поток до выхода из критической секции. Если внутри `lock` использовать `await`, то выполнение может приостановиться, а поток освободится, не разблокировав объект. Это может привести к дедлокам или некорректной работе синхронизации, поскольку поток может не завершить блокировку, оставив объект заблокированным для других потоков.

39:18
**Есть semaphore, есть semaphoreSlim. Знаешь ли про лайт классы и в чём разница? Что делает слим?** 

Ответ:
1. **Semaphore**:
    - `Semaphore` — это примитив синхронизации, который позволяет ограничить количество потоков, имеющих доступ к ресурсу.
    - Используется для межпроцессной синхронизации.
2. **SemaphoreSlim**:
    
    - `SemaphoreSlim` — это более легковесная версия `Semaphore`, предназначенная для внутрипроцессной синхронизации.
    - `SemaphoreSlim` более эффективен и имеет меньшие накладные расходы по сравнению с `Semaphore`.

`Semaphore` и `SemaphoreSlim` — это синхронизирующие примитивы, позволяющие ограничить количество потоков, которые могут одновременно выполнять определённый блок кода.

`SemaphoreSlim` — облегченная версия `Semaphore`, которая более эффективно использует ресурсы, потому что в большинстве случаев не использует ядро Windows для своей работы. Он предназначен для использования в .NET приложениях и подходит для сценариев, где необходима синхронизация внутри одного процесса, в то время как `Semaphore` может использоваться для синхронизации между разными процессами. `SemaphoreSlim` также быстрее и менее ресурсоёмкий.

41:18
**Расскажи про ключевые слова async, await. Что это такое и как работают Task под капотом?**

Ответ:
Ключевые слова `async` и `await` в C# используются для работы с асинхронными методами.

- `async` — используется для обозначения метода, который может содержать асинхронные операции и возвращать `Task`, `Task<T>` или `void`.
    
- `await` — применяется для ожидания завершения асинхронной операции без блокировки текущего потока. Когда выполнение достигает `await`, управление возвращается вызывающему коду до тех пор, пока операция не завершится.
    

Под капотом, когда метод помечен как `async`, компилятор преобразует его в **конечный автомат** (state machine), который управляет состояниями выполнения метода. Этот автомат переключает выполнение между состояниями, пока не завершит метод. `Task` представляет собой обещание (promise) завершения операции и может быть использован для продолжения выполнения кода после завершения асинхронной операции.


42:31
**Бывает ли так что асинхронный метод возвращает управление синхронно?**

Ответ:
Да, это возможно. Если метод, помеченный как `async`, завершает выполнение до того, как достигнет оператора `await`, он возвращает управление синхронно. Например, если метод сразу возвращает результат, `Task` завершится мгновенно, и управление вернется вызывающему коду без переключения контекста.

Если асинхронный метод завершается синхронно (например, если `Task` уже завершен), то управление возвращается синхронно.

```c#
public async Task MyAsyncMethod()
{
    await Task.CompletedTask;
    // Управление возвращается синхронно
}

```


43:55
**Ты пишешь await, всегда ли это освобождение потока, ожидание, возвращение или бывает так, что await отдаёт управление асинхронно?**

Ответ:
**Не всегда**:

- `await` освобождает поток выполнения только в том случае, если `Task` еще не завершен.
- Если `Task` уже завершен, `await` возвращает управление синхронно.

```c#
public async Task MyAsyncMethod()
{
    await Task.CompletedTask; // Управление возвращается синхронно
    await SomeAsyncOperation(); // Управление освобождается асинхронно
}
```


44:58
**Во что превращается метод, помеченный ключевым словом async? Это вопрос про конечный автомат**

Ответ:
Метод, помеченный ключевым словом `async`, компилятор преобразует в **конечный автомат** (state machine). Этот автомат управляет состояниями метода и определяет, когда метод должен приостановиться, вернуть управление вызывающему коду и когда возобновить выполнение после завершения асинхронной операции. Конечный автомат включает несколько состояний, которые управляют потоком выполнения и обработкой исключений в асинхронном методе.

Конечный автомат управляет состоянием выполнения метода и переходами между состояниями.

Компилятор преобразует этот метод в класс, реализующий интерфейс `IAsyncStateMachine`, который управляет состоянием выполнения метода.

#### БД

45:57
**Расскажи про опыт работы с базами**

48:13
**Приведи пару примеров Join, какие они бывают?**

Ответ:
- **INNER JOIN**: Возвращает записи, которые имеют совпадения в обеих таблицах. Пример:    
```sql
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;

```
    
- **LEFT JOIN (или LEFT OUTER JOIN)**: Возвращает все записи из левой таблицы и совпадающие записи из правой таблицы. Если совпадения нет, возвращаются `NULL` значения для правой таблицы. Пример:

```sql
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;

```

- **RIGHT JOIN (или RIGHT OUTER JOIN)**: Аналогично `LEFT JOIN`, но возвращает все записи из правой таблицы и совпадающие записи из левой таблицы.
    
- **FULL OUTER JOIN**: Возвращает все записи, когда есть совпадения в одной из таблиц. Если нет совпадений, возвращает `NULL` значения для несоответствующей таблицы.


49:50
**Что такое Having?**

Ответ:
`HAVING` — это оператор SQL, который используется для фильтрации результатов группировки, определённой с помощью `GROUP BY`. Он позволяет наложить условия на агрегатные функции (например, `SUM`, `COUNT`, `AVG`), что невозможно сделать с помощью оператора `WHERE`, который работает с отдельными строками. Пример:

```sql
SELECT department_id, COUNT(employee_id) 
FROM employees 
GROUP BY department_id 
HAVING COUNT(employee_id) > 10;
```
Этот запрос возвращает только те отделы, где количество сотрудников больше 10.


50:30
**Приходилось ли работать с какими-то API в sql? Например, command table expressions, view, хранимые процедуры?**

Ответ:
1. **Common Table Expressions (CTE)**:
    - Позволяют создавать временные таблицы, которые можно использовать в запросе.
        
2. **Views**:
    - Представления (views) позволяют создавать виртуальные таблицы, которые представляют результат запроса.
        
3. **Хранимые процедуры**:
    - Хранимые процедуры позволяют выполнять сложные операции на сервере базы данных.


51:03
**Приходилось ли делать миграции баз данных? Не данных, а схемы, когда создаётся новая таблица, колонка или другое изменение инфоструктуры?**

Ответ:
Да, у меня есть опыт работы с миграциями баз данных, включая изменения схемы. Я использую инструменты миграции, такие как Entity Framework Migrations или Flyway, для управления изменениями схемы базы данных. Это позволяет легко создавать новые таблицы, добавлять или изменять колонки, управлять индексами и другими изменениями, а также отслеживать версии схемы базы данных.

52:04
**Как сделать обратно совместимую миграцию? К примеру, есть сервис версии1, у него 2 колонки,  далее вам нужно добавить новую колонку, вы делайте для этого новую сборку, миграции. Накатили, по каким-то причинам нужно откатиться обратно. Как откатиться назад так, чтобы ничего не сломалось?** 

Ответ:
Для обеспечения обратной совместимости миграций можно использовать следующие стратегии:
1. **Добавление новых колонок с возможностью NULL**:
    
    - При добавлении новой колонки, которая может быть NULL, старые версии приложения могут продолжать работать без изменений.
    - Пример:
        
        `ALTER TABLE Orders ADD COLUMN NewColumn VARCHAR(255) NULL;`
        
2. **Создание новых таблиц**:
    
    - Новые таблицы могут быть добавлены без изменения существующих таблиц, что позволяет старым версиям приложения продолжать работать.
3. **Использование триггеров и представлений**:
    
    - Триггеры и представления могут помочь в обеспечении совместимости между старыми и новыми версиями схемы.



52:55
**А если есть желание удалить какую-то колонку наоборот?**

Ответ:
Удаление колонки требует более осторожного подхода:

1. **Обновление кода**: Сначала удалить все зависимости от колонки в коде. Убедиться, что данные больше не записываются в эту колонку и она не используется в запросах.
2. **Миграция данных**: Если данные в колонке важны, их можно перенести в другую колонку или таблицу.
3. **Удаление колонки**: После того как сервисы были обновлены и не используют колонку, можно безопасно удалить её с помощью миграции.


54:30
**Представим что никаких зависимостей нет. Просто есть какая-то колонка, в которую пишутся данные, мы поняли что они никак не используются и хотим её удалить. Никаких триггиров, внешних ключей на ней не завязано. Какая есть стратегия, по которой мы можем удалить эту колонку, при этом сохранив обратную совместимость?**

Ответ:
Для удаления колонки, сохраняя обратную совместимость:

1. **Пометить колонку как устаревшую**: Оповестить команду о том, что колонка будет удалена, и убедиться, что код больше не зависит от неё.
2. **Миграция данных**: Перенести важные данные в новую структуру или колонку, если необходимо.
3. **Проверка и тестирование**: Обеспечить, чтобы никакие системы не полагались на удаляемую колонку.
4. **Удаление колонки**: Удалить колонку в базе данных.
5. **Откат**: В случае необходимости отката можно вернуть старую колонку в базе данных и повторно мигрировать данные, если потребуется.


58:40
**Приходилось ли использовать индексы?**

Ответ:
Индексы позволяют ускорить операции поиска данных и сортировки, особенно на больших таблицах. Я также использовал уникальные индексы для обеспечения целостности данных и предотвращения дублирования записей.


59:39
**Есть понимание за счёт чего появляется скорость при использовании индексов?**

Ответ:
Индексы ускоряют выполнение запросов за счет создания структуры данных (например, B-tree), которая позволяет быстро находить строки в таблице. Вместо полного сканирования таблицы, индексы позволяют быстро находить нужные строки, что значительно ускоряет выполнение запросов.

01:01:24
**Приходилось ли работать с транзакциями в базах данных?**

Ответ:


#### Архитектура и написание кода

01:04:17
**Расскажи про пару принципов из SOLID**

01:07:12
**Приведи пример, когда SOLID не подходит**

Ответ:
Принципы SOLID могут быть излишне сложными для небольших проектов или прототипов, где нет необходимости в гибкости и масштабируемости. В этих случаях может быть разумнее написать более простой код, без создания абстракций, что позволит быстрее достичь рабочих результатов. Кроме того, излишнее следование SOLID может привести к переусложнению кода и потере производительности.


01:08:34
**Расскажи про инверсию зависимостей, что это за принцип, где применяется**

Ответ:


01:09:50
**В чём смысл создание абстракций? Большинство создаёт какую-то абстракцию, у которой есть какая-то 1 конкретная реализация и в чём тут тогда смысл?**

Ответ:
Создание абстракций позволяет отделить логику приложения от деталей реализации, что упрощает модификацию и расширение кода. Даже если в текущий момент есть только одна реализация интерфейса, абстракция позволяет легко добавлять новые реализации в будущем без изменения основного кода. Это также облегчает тестирование, так как можно заменять реальные зависимости на mock-объекты.

01:10:56
**Приходилось ли работать с брокерами сообщений?**

Ответ:
Да, у меня есть опыт работы с брокерами сообщений, такими как RabbitMQ, Apache Kafka и Azure Service Bus. Я использовал их для организации асинхронного обмена сообщениями между микросервисами, что позволяет уменьшить связанность и повысить устойчивость системы.

01:12:14
**Для чего вообще брокеры нужны? В каких системах брокеры полезны?**

Ответ:
Брокеры сообщений используются для асинхронного обмена данными между компонентами системы. Они полезны в микросервисной архитектуре, где необходимо уменьшить связанность между сервисами и обеспечить надежную передачу сообщений. Брокеры помогают обеспечить устойчивость к сбоям, управлять нагрузкой и упрощать масштабирование системы.

1. **Декуплинг компонентов**:
    
    - Брокеры позволяют компонентам системы работать независимо друг от друга.
2. **Масштабируемость**:
    
    - Брокеры позволяют легко масштабировать систему, добавляя новые компоненты без изменения существующего кода.
3. **Надежность**:
    
    - Брокеры обеспечивают надежную доставку сообщений, даже если один из компонентов временно недоступен.


01:13:02
**Можно ли реализовать микросервисную архитектуру без брокеров?**

Ответ:
Микросервисную архитектуру можно реализовать без брокеров, используя синхронное взаимодействие через HTTP или gRPC. Однако это увеличивает связанность сервисов, снижает устойчивость к сбоям и усложняет масштабирование. Брокеры сообщений позволяют реализовать более гибкую и устойчивую архитектуру, что делает их предпочтительным выбором в большинстве случаев.

01:13:50
**Можно ли организовать асинхронность без брокера сообщений?**

Ответ:
Да, асинхронность можно организовать и без брокера сообщений, например, с помощью задач и потоков в языке программирования. Однако в распределённых системах, где требуется обмен сообщениями между разными сервисами или компонентами, брокеры сообщений становятся более эффективным и надёжным решением для обеспечения асинхронного взаимодействия.

1. **Асинхронные вызовы**:
    
    - Использование асинхронных вызовов (например, `async`/`await` в C#) для выполнения задач без блокировки основного потока.
2. **Очереди задач**:
    
    - Использование очередей задач (например, Hangfire) для планирования и выполнения задач в фоновом режиме.

01:15:21
**Если с брокерами удобнее, то какие задачи они решают? Если они решают какие-то задачи, значит существуют и проблемы, что это за проблемы?**

Ответ:
Брокеры сообщений решают следующие задачи:

- **Асинхронность**: Позволяют сервисам обмениваться сообщениями без необходимости ожидания ответа.
- **Устойчивость к сбоям**: Сообщения сохраняются в очереди до тех пор, пока они не будут доставлены, что повышает надёжность системы.
- **Масштабируемость**: Сервисы могут быть масштабированы независимо, так как взаимодействие между ними осуществляется через брокера.

Проблемы использования брокеров сообщений:

- **Сложность конфигурации и управления**: Настройка и поддержка брокера могут быть сложными, особенно в крупномасштабных системах.
- **Задержки в доставке**: В зависимости от конфигурации и нагрузки на брокера, могут возникать задержки в доставке сообщений.
- **Трудности отладки**: Асинхронный обмен сообщениями сложнее отлаживать по сравнению с синхронными вызовами.

#### Практическая задача

01:16:11
Представь что ты находишься в лесу или в горах, где у тебя очень плохая связь и ты хочешь загрузить на какой-то сервер файл, очень большого объёма. К примеру, ты снял красивое видео и очень хочешь сейчас поделиться им с друзьями. Хочется загрузить это видео, но связь постоянно теряется, то всё норм, то LTE, то её нету и напрямую загрузить не получится.

Задача: 
Разработать сервис, в который из таких плохих условий мы сможем загружать файл успешно. Нужно разработать API.